================================================================================
  LABEL: ask_for_fixes
  TIME:  2026-02-20_02-33-25
  MODE:  GEMINI
================================================================================

>>> PROMPT SENT TO LLM:
--------------------------------------------------------------------------------
You are a code-fixing AI. Here are the test errors:

  - Test: collection_error:tests/test_formatter.py | File: tests/test_formatter.py | Line: 0 | Error: D:\ProgramData\miniconda3\Lib\site-packages\_pytest\python.py:493: in importtestmodule
    mod = import_path(

Here are the source files:


--- FILE: run_tests.py ---
"""Run pytest (with --continue-on-collection-errors) and flake8, save full output"""
import subprocess
import sys
import os

os.chdir(os.path.dirname(os.path.abspath(__file__)))

lines = []

lines.append("=" * 70)
lines.append("PYTEST RESULTS (--continue-on-collection-errors)")
lines.append("=" * 70)
result = subprocess.run(
    [sys.executable, "-m", "pytest", "tests/", "-v", "--tb=short",
     "--continue-on-collection-errors"],
    capture_output=True, text=True
)
lines.append(result.stdout)
if result.stderr:
    lines.append("STDERR:" + result.stderr)

lines.append("\n" + "=" * 70)
lines.append("FLAKE8 RESULTS")
lines.append("=" * 70)
result2 = subprocess.run(
    [sys.executable, "-m", "flake8", "src/", "--max-line-length=100"],
    capture_output=True, text=True
)
lines.append(result2.stdout if result2.stdout else "(no flake8 warnings)")
if result2.stderr:
    lines.append("STDERR:" + result2.stderr)

output = "\n".join(lines)
with open("test_results.txt", "w", encoding="utf-8") as f:
    f.write(output)

print(output)


--- FILE: src/config.py ---
"""
Configuration manager for the application.
"""

import os
import json

DEFAULT_CONFIG = {
    "host": "localhost",
    "port": 8080,
    "debug": False,
    "max_retries": 3,
    "timeout": 30,
}


class ConfigManager:
    """Manages application configuration."""

    def __init__(self, config_path=None):
        self.config = DEFAULT_CONFIG.copy()
        if config_path:
            self.load_from_file(config_path)

    def load_from_file(self, path):
        """Load configuration from a JSON file."""
        try:
            with open(path, "r") as f:
                data = json.load(f)
                self.config.update(data)
        except FileNotFoundError:
            pass
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON in config file: {e}")

    def get(self, key, default=None):
        """Get a configuration value."""
        return self.config.get(key, default)

    def set(self, key, value):
        """Set a configuration value."""
        # TYPE_ERROR: port should always be an int, but no type check is performed
        self.config[key] = value

    def get_port(self):
        """Get the port as integer."""
        # TYPE_ERROR: returns str instead of int when env var is set
        port = os.environ.get("APP_PORT", self.config["port"])
        return int(port)

    def get_database_url(self):
        """Build database URL from config."""
        host = self.config.get("db_host", "localhost")
        port = self.config.get("db_port", 5432)
        name = self.config.get("db_name", "mydb")
        user = self.config.get("db_user", "admin")
        password = self.config.get("db_password", "")
        return f"postgresql://{user}:{password}@{host}:{port}/{name}"

    def validate(self):
        """Validate the configuration."""
        required_keys = ["host", "port"]
        for key in required_keys:
            if key not in self.config:
                raise ValueError(f"Missing required config key: {key}")
        # TYPE_ERROR: port must be int, but check is missing
        if not isinstance(self.config["port"], int):
            raise TypeError("port must be an integer")
        return True

    def to_dict(self):
        """Return config as dict."""
        return self.config.copy()

    def __repr__(self):
        return f"ConfigManager({self.config})"


--- FILE: src/data_processor.py ---
"""
Data processing module with various operations.
"""
import json
import csv
from typing import List, Dict, Any


def process_data(data: List[Dict]) -> List[Dict]:
    """Process a list of records."""
    result = []
    for item in data:
        processed = {
            "id": item.get("id"),
            "name": item.get("name", "").strip(),
            "value": item.get("value", 0),
        }
        result.append(processed)
    return result


def filter_by_value(data: List[Dict], threshold: int) -> List[Dict]:
    """Filter records where value is above threshold."""
    # LOGIC ERROR line 22: should be > threshold, not < threshold
    return [item for item in data if item.get("value", 0) > threshold]


def compute_statistics(values: List[float]) -> Dict[str, float]:
    """Compute basic statistics for a list of values."""
    if not values:
        return {}
    n = len(values)
    mean = sum(values) / n
    variance = sum((x - mean) ** 2 for x in values) / n
    std_dev = variance ** 0.5
    return {
        "mean": mean,
        "std_dev": std_dev,
        "min": min(values),
        "max": max(values),
        "count": n,
    }


def load_json_file(filepath: str) -> Any:
    """Load JSON from a file."""
    with open(filepath, "r") as f:
        return json.load(f)


def save_json_file(filepath: str, data: Any) -> None:
    """Save data to a JSON file."""
    with open(filepath, "w") as f:
        json.dump(data, f, indent=2)


def read_csv(filepath: str) -> List[Dict]:
    """Read a CSV file and return list of dicts."""
    rows = []
    with open(filepath, "r", newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            rows.append(dict(row))
    return rows


def flatten_list(nested: List) -> List:
    """Flatten a nested list one level deep."""
    flat = []
    for item in nested:
        if isinstance(item, list):
            flat.extend(item)
        else:
            flat.append(item)
    return flat


def group_by_key(data: List[Dict], key: str) -> Dict[str, List]:
    """Group a list of dicts by a given key."""
    groups = {}
    for item in data:
        k = item.get(key, "unknown")
        if k not in groups:
            groups[k] = []
        groups[k].append(item)
    return groups


--- FILE: src/formatter.py ---
"""
String formatting utilities.
"""


def format_name(first, last):
    """Format first and last name into full name."""  # INDENTATION ERROR: uses 2 spaces instead of 4 spaces (inconsistent)
    full_name = first + " " + last
    return full_name.strip()


def format_currency(amount, currency="USD"):
    """Format a number as currency string."""
    if not isinstance(amount, (int, float)):
        raise TypeError(f"Expected number, got {type(amount).__name__}")
    return f"{currency} {amount:,.2f}"


def format_percentage(value, decimal_places=2):
    """Format a value as percentage."""
    if not isinstance(value, (int, float)):
        raise TypeError(f"Expected number, got {type(value).__name__}")
    return f"{value * 100:.{decimal_places}f}%"


def truncate_string(s, max_len, suffix="..."):
    """Truncate a string to max_len characters."""
    if not isinstance(s, str):
    raise TypeError("Input must be a string")
    if len(s) <= max_len:
        return s
    return s[:max_len - len(suffix)] + suffix


def pad_string(s, width, char=" ", align="left"):
    """Pad a string to a given width."""
    if align == "left":
        return s.ljust(width, char)
    elif align == "right":
        return s.rjust(width, char)
    elif align == "center":
        return s.center(width, char)
    else:
        raise ValueError(f"Invalid align: {align}")


def snake_to_camel(snake_str):
    """Convert snake_case to camelCase."""
    components = snake_str.split("_")
    return components[0] + "".join(x.title() for x in components[1:])


def camel_to_snake(camel_str):
    """Convert camelCase to snake_case."""
    import re
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", camel_str)
    return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()


--- FILE: src/utils.py ---
"""
Utility functions for the application.
"""

import datetime


def add_numbers(a, b):
    """Add two numbers together."""
    return a + b


def multiply_numbers(a, b):
    """Multiply two numbers."""
    return a * b


def calculate_average(numbers):
    """Calculate the average of a list of numbers."""
    if len(numbers) == 0:
        return 0
    total = sum(numbers)
    return total / len(numbers)


def find_max(numbers):
    """Find the maximum value in a list."""
    if not numbers:
        return None
    max_val = numbers[0]
    for num in numbers:
        if num > max_val:
            max_val = num
    return max_val


def find_min(numbers):
    """Find the minimum value in a list."""
    if not numbers:
        return None
    min_val = numbers[0]
    for num in numbers:
        if num < min_val:
            min_val = num
    return min_val


def is_palindrome(s):
    """Check if a string is a palindrome."""
    s = s.lower().replace(" ", "")
    return s == s[::-1]


def factorial(n):
    """Calculate the factorial of a number."""
    if n <= 1:
        return 1
    return n * factorial(n - 1)


def get_formatted_date():
    """Get the current date formatted as YYYY-MM-DD."""
    today = datetime.date.today()
    return str(today)


def count_words(text):
    """Count words in a string."""
    if not text:
        return 0
    words = text.split()
    return len(words)


def reverse_string(s):
    """Reverse a string."""
    return s[::-1]


def is_even(n):
    """Check if a number is even."""
    return n % 2 == 0


def square(n):
    """Return the square of a number."""
    return n * n


--- FILE: src/validator.py ---
"""
Validation functions for the application.
"""


def validate_email(email):
    """Validate an email address format."""  # SYNTAX ERROR: missing colon after function definition â€” line 8
    if not isinstance(email, str):
        return False
    if "@" not in email:
        return False
    parts = email.split("@")
    if len(parts) != 2:
        return False
    local, domain = parts
    if not local or not domain:
        return False
    if "." not in domain:
        return False
    return True


def validate_phone(phone):
    """Validate a phone number (10 digits)."""
    if not isinstance(phone, str):
        return False
    digits = phone.replace("-", "").replace(" ", "").replace("(", "").replace(")", "")
    return len(digits) == 10 and digits.isdigit()


def validate_age(age):
    """Validate that age is a positive integer between 0 and 150."""
    if not isinstance(age, int):
        return False
    return 0 <= age <= 150


def validate_username(username):
    """Validate username: 3-20 chars, alphanumeric and underscores only."""
    if not isinstance(username, str):
        return False
    if len(username) < 3 or len(username) > 20:
        return False
    import re
    pattern = r'^[a-zA-Z0-9_]+$'
    return bool(re.match(pattern, username))


def validate_password(password):
    """Validate password: at least 8 chars, must contain letter and digit."""
    if not isinstance(password, str):
        return False
    if len(password) < 8:
        return False
    has_letter = any(c.isalpha() for c in password)
    has_digit = any(c.isdigit() for c in password)
    return has_letter and has_digit



For each bug, provide a fix.

Respond ONLY with valid JSON:
{
  "fixes": [
    {
      "file": "relative/path/to/file.py",
      "line": <line_number>,
      "old_code": "<exact current line>",
      "new_code": "<corrected line>",
      "bug_type": "<SYNTAX|LOGIC|IMPORT|LINTING|TYPE_ERROR|INDENTATION|OTHER>",
      "description": "<short description>"
    }
  ],
  "commit_title": "[AI-AGENT] <summary of fixes>"
}

IMPORTANT:
- "old_code" must match the EXACT current line (whitespace matters).
- "new_code" is the replacement. Use "" to delete a line.
- Include ALL fixes needed.

--------------------------------------------------------------------------------

<<< RESPONSE FROM LLM:
--------------------------------------------------------------------------------
```json
{
  "fixes": [
    {
      "file": "src/formatter.py",
      "line": 8,
      "old_code": " full_name = first + \" \" + last",
      "new_code": "    full_name = first + \" \" + last",
      "bug_type": "INDENTATION",
      "description": "Corrected inconsistent indentation from 2 spaces to 4 spaces in format_name function."
    },
    {
      "file": "src/formatter.py",
      "line": 26,
      "old_code": "    raise TypeError(\"Input must be a string\")",
      "new_code": "        raise TypeError(\"Input must be a string\")",
      "bug_type": "INDENTATION",
      "description": "Corrected indentation for the TypeError raise statement inside the if block in truncate_string, fixing a syntax error."
    },
    {
      "file": "src/validator.py",
      "line": 8,
      "old_code": "def validate_email(email)",
      "new_code": "def validate_email(email):",
      "bug_type": "SYNTAX",
      "description": "Added missing colon to the validate_email function definition."
    }
  ],
  "commit_title": "[AI-AGENT] Fix syntax and indentation errors in formatter and validator modules"
}
```
--------------------------------------------------------------------------------
